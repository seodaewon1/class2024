<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 실행하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
            <ul>
                <li><a href="object01.html">문자열 객체</a></li>
                <li><a href="object02.html">배열 객체</a></li>
                <li><a href="object03.html">수학 객체</a></li>
                <li><a href="object04.html">숫자 객체</a></li>
                <li><a href="object05.html">브라우저 객체</a></li>
                <li><a href="object06.html">요소 객체</a></li>
                <li><a href="object07.html">이벤트 객체</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#">01. 함수 : 선언적 함수</a></li>
                <li><a href="#">02. 함수 : 익명 함수</a></li>
                <li><a href="#">03. 함수 : 매개변수 함수</a></li>
                <li><a href="#">04. 함수 : 리턴값 함수</a></li>
                <li><a href="#">05. 함수 : 매개변수 + 리턴값 함수</a></li>

                <li><a href="#">06. 화살표 함수 : 선언적 함수</a></li>
                <li><a href="#">07. 화살표 함수 : 익명 함수</a></li>
                <li><a href="#">08. 화살표 함수 : 매개변수 함수</a></li>
                <li><a href="#">09. 화살표 함수 : 리턴값 함수</a></li>
                <li><a href="#">10. 화살표 함수 : 매개변수 + 리턴값 함수</a></li>

                <li><a href="#">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                <li><a href="#">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                <li><a href="#">13. 함수 유형 : 함수와 배열를 이용한 형태</a></li>
                <li><a href="#">14. 함수 유형 : 함수와 객체를 이용한 형태</a></li>
                <li><a href="#">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                <li><a href="#">16. 함수 유형 : 객체 안에 함수를 이용한 형태</a></li>
                <li><a href="#">17. 함수 유형 : 객체 생성자 함수</a></li>
                <li><a href="#">18. 함수 유형 : 프로토타입 함수</a></li>
                <li><a href="#">19. 함수 유형 : 객체 리터럴 함수</a></li>

                <li><a href="#">20. 함수 : 즉시 실행 함수</a></li>
                <li><a href="#">21. 함수 : 파라미터 함수</a></li>
                <li><a href="#">22. 함수 : 재귀 함수</a></li>
                <li><a href="#">23. 함수 : 콜백 함수</a></li>
                <li><a href="#">24. 함수 : 비동기 방식 : 콜백 함수</a></li>
                <li><a href="#">25. 함수 : 비동기 방식 : 프로미스</a></li>
                <li><a href="#">26. 함수 : 비동기 방식 : asyne/awiat</a></li>
                <li><a href="#">27. 함수 : 중첩 함수</a></li>
                <li><a href="#">28. 함수 : 클로저</a></li>

                <li><a href="#">29. 클래스 : 기본</a></li>
                <li><a href="#">30. 클래스 : 상속</a></li>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 함수 : 선언적 함수</h3>
                <p>
                    선언적 함수(Declaration)는 이름을 가진 함수로, 함수를 선언할 때 이름을 붙여주는 방식입니다. 이 이름을 사용하여 함수를 호출할 수 있습니다.
                </p>
                <pre><code>{
    function func() {
        console.log("01. 함수가 실행되었습니다.")
    }
    func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            01. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
            <div id="sample02" class="sample">
                <h3>02. 함수 : 익명 함수</h3>
                <p>
                    익명 함수는 이름이 없는 함수로, 주로 변수에 할당하여 사용합니다. 익명 함수는 선언된 위치에서부터 코드가 순차적으로 실행될 때 생성됩니다.
                    따라서 함수를 호출하기 전에 해당 함수가 선언되어 있어야 합니다.
                </p>
                <pre><code>{
    const func = function () {
        console.log("02. 함수가 실행되었습니다.")
    }
    func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            02. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->
            <div id="sample03" class="sample">
                <h3>03. 함수 : 매개변수 함수</h3>
                <p>
                    함수를 호출할 때 특정 매개변수에 값을 전달하지 않았을 경우, 미리 정의해둔 기본값을 사용하는 매개변수입니다.
                </p>
                <pre><code>{
    function func(str) {
        console.log(str);
    }
    func("03. 함수가 실행되었습니다.");

    // 익명 함수
    const func1 = function (str) {
        console.log(str);
    }
    func1("03. 함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            03. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->
            <div id="sample04" class="sample">
                <h3>04. 함수 : 리턴값 함수</h3>
                <p>
                    함수에서 처리한 결과를 외부로 전달하기 위해 사용하는 값입니다.
                    함수의 리턴값은 return 키워드를 사용하여 지정할 수 있으며, 이를 통해 함수 내부에서 계산하거나 처리한 결과를 함수 외부로 전달할 수 있다.
                </p>
                <pre><code>{
    // 선언적 함수
    function func() {
        return "04. 함수가 실행되었습니다.";
    }
    console.log(func());
    // 익명 함수
    const func1 = function () {
        return "04. 함수가 실행되었습니다.";
    }
    console.log(func1());
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            04. 함수가 실행되었습니다.<br>
                            04. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->
            <div id="sample05" class="sample">
                <h3>05. 함수 : 매개변수 + 리턴값 함수</h3>
                <p>
                    자바스크립트에서 함수는 특정 작업을 수행하는 코드 블록입니다.
                    매개변수를 사용하여 함수에 값을 전달하고, 리턴값을 통해 함수의 실행 결과를 반환할 수 있습니다. 이러한 기능은 코드의 재사용성과 모듈성을 높여줍니다.
                </p>
                <pre><code>{
    // 선언적 함수
    function func(str) {
        return str;
    }
    console.log(func("05. 함수가 실행되었습니다."));
    // 익명함수
    const func1 = function (str) {
        return (str);
    }
    console.log(func1("05. 함수가 실행되었습니다."));
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            05. 함수가 실행되었습니다.<br>
                            05. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->
            <div id="sample06" class="sample">
                <h3>06. 화살표 함수 : 선언적 함수</h3>
                <p>
                    화살표 함수는 function 키워드 없이 함수를 정의할 수 있는 ES6에서 도입된 새로운 함수 표현식입니다.
                    => 기호를 사용하여 간결하게 함수를 표현할 수 있습니다.
                </p>
                <pre><code>{
    //선언적 함수
    function func() {
        console.log("06. 함수가 실행되었습니다.")
    }
    func();
    //선억적 함수(화살표 함수)
    func = () => {
        console.log("06. 함수가 실행되었습니다.")
    }
    func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            06. 함수가 실행되었습니다.<br>
                            06. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->
            <div id="sample07" class="sample">
                <h3>07. 화살표 함수 : 익명 함수</h3>
                <p>
                    자바스크립트에서 화살표 함수는 간결한 문법으로 익명 함수를 정의하는 데 사용됩니다.
                    화살표 함수는 function 키워드 없이 함수를 선언할 수 있으며, 주로 콜백 함수나 함수 표현식에서 사용됩니다.
                    익명 함수는 이름이 없는 함수를 말하며, 화살표 함수는 이러한 익명 함수의 한 형태로 볼 수 있습니다.
                </p>
                <pre><code>{
    //익명 함수
    const func = function () {
        console.log("07. 함수가 실행되었습니다.")
    }
    func();

    const func1 = () => {
        console.log("07. 함수가 실행되었습니다.")
    }
    func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            07. 함수가 실행되었습니다.<br>
                            07. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->
            <div id="sample08" class="sample">
                <h3>08. 화살표 함수 : 매개변수 함수</h3>
                <p>
                    자바스크립트의 화살표 함수는 매개변수를 다루는 방식이 유연하고 간결합니다.
                    화살표 함수는 매개변수가 없거나 여러 개 있을 때, 그리고 기본값을 가질 때의 사용법이 다양하게 제공됩니다.
                </p>
                <pre><code>{
    // 선언적 함수
    func = (str) => {
        console.log(str);
    }
    func("08. 함수가 실행되었습니다.");
    // 익명 함수
    const func1 = (str) => {
        console.log(str);
    }
    func1("08. 함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            08. 함수가 실행되었습니다.<br>
                            08. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->
            <div id="sample09" class="sample">
                <h3>09. 화살표 함수 : 리턴값 함수</h3>
                <p>
                    화살표 함수는 간결한 문법으로 함수를 정의할 수 있게 해주며, 리턴값 처리도 매우 유연합니다.
                    화살표 함수는 표현식을 평가하고 그 결과를 자동으로 반환하는 특징이 있습니다.
                    화살표 함수는 {} 없이 작성된 표현식의 결과를 자동으로 반환합니다.
                </p>
                <pre><code>{
    // 선언적 함수
    func = () => {
        return "09. 함수가 실행되었습니다.";
    }
    console.log(func());
    // 익명 함수
    const func1 = () => {
        return "09. 함수가 실행되었습니다.";
    }
    console.log(func1());
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            09. 함수가 실행되었습니다.<br>
                            09. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample09 -->
            <div id="sample10" class="sample">
                <h3>10. 화살표 함수 : 매개변수 + 리턴값 함수</h3>
                <p>
                    자바스크립트의 화살표 함수는 간결한 문법으로 함수를 정의할 수 있게 해주며, 매개변수와 리턴값을 다루는 방식도 매우 유연합니다.
                    화살표 함수는 기본적으로 매개변수를 받아 표현식을 평가하고 그 결과를 반환하는 구조를 가지고 있습니다.
                </p>
                <pre><code>{
    // 익명 함수(화살표함수) + 매개변수 + 리턴값
    const func = (str) => {
        return (str)
    }
    console.log(func("10. 함수가 실행되었습니다."))
    // 매개변수 하나이면 괄호 생략 가능
    const func1 = str => {
        return str;
    }
    console.log(func1("10. 함수가 실행되었습니다."));
    // 리턴 생략
    const func2 = str => str;
    console.log(func2("10. 함수가 실행되었습니다."));
    // 선언적 함수(가독성X)
    func3 = str => str;
    console.log(func3("10. 함수가 실행되었습니다."));
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            10. 함수가 실행되었습니다.<br>
                            10. 함수가 실행되었습니다.<br>
                            10. 함수가 실행되었습니다.<br>
                            10. 함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample10 -->
            <div id="sample11" class="sample">
                <h3>11. 함수 유형: 함수와 매개변수를 이용한 형태</h3>
                <p>
                    자바스크립트에서 함수는 코드를 재사용할 수 있게 해주는 중요한 기능입니다. 매개변수를 이용하면 함수를 더 유연하게 사용할 수 있습니다.
                    함수는 function 키워드를 사용하여 정의할 수 있으며, 매개변수를 통해 외부에서 값을 전달받을 수 있습니다.
                </p>
                <pre><code>{
    function func(num, str) {
        console.log(num + "." + str);
        console.log(`${num}.${str}`);
    }
    func(11, "함수가 실행되었습니다.")
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            11.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample11 -->
            <div id="sample12" class="sample">
                <h3>12. 함수 유형: 함수와 변수를 이용한 형태</h3>
                <p>
                    자바스크립트에서 함수와 변수를 활용하는 방법은 프로그래밍의 기본이자, 코드를 효율적으로 관리할 수 있는 중요한 방법입니다.
                    자바스크립트에서는 변수에 함수를 대입하여 해당 변수를 함수처럼 사용할 수 있습니다.이 방법을 통해 함수를 다른 변수에 할당하고, 그 변수를 통해 함수를 호출할 수 있습니다.
                    함수를 다른 함수의 매개변수로 전달하여, 함수 내부에서 전달받은 함수를 호출할 수 있습니다.
                </p>
                <pre><code>{
    const num = 12;
    const str = "함수가 실행되었습니다."

    function func(num, str) {
        console.log(`${num}.${str}`);
    }
    func(num, str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            12.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample12 -->
            <div id="sample13" class="sample">
                <h3>13. 함수 유형: 함수와 배열를 이용한 형태</h3>
                <p>
                    자바스크립트에서 배열과 함수를 함께 사용하는 것은 데이터를 효율적으로 처리하고,
                    코드의 가독성을 높이는 데 매우 중요합니다. 배열 메소드를 활용하면, 복잡한 데이터 처리를 몇 줄의 코드로 간단하게 해결할 수 있습니다.<br>
                    -기본메소드<br>
                    push(): 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다.<br>
                    pop(): 배열에서 마지막 요소를 제거하고, 그 요소를 반환합니다.<br>
                    shift(): 배열에서 첫 번째 요소를 제거하고, 그 요소를 반환합니다.<br>
                    unshift(): 배열의 시작에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다.<br>
                    splice(): 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다.<br>
                </p>
                <pre><code>{
    const num = [13, 14];
    const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."]

    function func(num, str) {
        console.log(`${num}.${str}`);
    }
    func(num[0], str[0]);
    func(num[1], str[1]);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            13.함수가 실행되었습니다.<br>
                            14.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample13 -->
            <div id="sample14" class="sample">
                <h3>14. 함수 유형: 함수와 객체를 이용한 형태</h3>
                <p>
                    함수는 작업을 수행하는 코드의 집합이며, 객체는 속성과 메소드를 포함할 수 있는 데이터의 집합입니다.<br>
                    객체 내 함수(메소드) 정의: 객체의 메소드는 객체의 속성값으로 함수를 할당하여 정의할 수 있습니다.
                    메소드를 통해 객체의 내부 데이터를 처리하거나, 객체의 상태를 변경하는 작업을 수행할 수 있습니다.
                </p>
                <pre><code>{
    const info = {
        num: 15,
        str: "함수가 실행되었습니다."
    }
    function func(num, str) {
        console.log(`${num}.${str}`);
    }
    func(info.num, info.str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->
            <div id="sample15" class="sample">
                <h3>15. 함수 유형: 함수와 객체 및 배열을 이용한 형태</h3>
                <p>
                    함수, 객체, 그리고 배열을 조합하면 데이터를 효과적으로 구조화하고 관리할 수 있습니다.
                    함수를 사용하여 객체를 생성하고, 그 객체들을 배열에 저장하거나 배열을 반복하여 처리하는 등의 작업을 할 수 있습니다.
                </p>
                <pre><code>{
    const info = [
        { num: 16, str: "함수가실행되었습니다." },
        { num: 17, str: "함수가실행되었습니다." }
    ]
    function func(num, str) {
        console.log(`${num}.${str}`);
    }
    func(info[0].num, info[0].str);
    func(info[1].num, info[1].str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            16.함수가 실행되었습니다.<br>
                            17.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample15 -->
            <div id="sample16" class="sample">
                <h3>16. 함수 유형: 객체 안에 함수를 이용한 형태</h3>
                <p>
                    객체의 상태를 변경하거나 특정 동작을 수행하는 메서드를 정의하는 데 사용됩니다. 이러한 함수를 객체의 메서드라고 합니다.
                    동일한 동작을 서로 다른 객체에 대해 반복적으로 구현할 필요가 없으므로 코드의 재사용성이 향상됩니다.
                </p>
                <pre><code>{
    const info = {
        num: 18,
        str: "함수가 실행되었습니다.",
        result: () => {
            console.log(`${info.num}.${info.str}`);
        }
    }
    info.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            18.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample16 -->
            <div id="sample17" class="sample">
                <h3>17. 함수 유형: 객체 생성자 함수</h3>
                <p>
                    객체 생성자 함수는 객체를 만들기 위한 템플릿 역할을 합니다. 객체 생성자 함수를 사용하면 동일한 유형의 여러 객체를 손쉽게 만들 수 있습니다. 객체 생성자 함수는 클래스와 유사한
                    역할을 하며, 이를 사용하여 객체를 생성할 때마다 속성과 메서드를 지정할 수 있습니다.
                    예시 - Func라는 객체 생성자 함수를 정의했습니다. 이 함수는 num과 str 두 개의 매개변수를 받아서 객체를 생성합니다. 이 객체는 num과 asr 속성을 가지며,
                    result라는 메서드도 포함하고 있습니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
        this.result = () => {
            console.log(`${this.num}.${this.str}`);
        }
    }
    // 인스턴스 생성
    const info1 = new Func(19, " 함수가 실행되었습니다.");
    const info2 = new Func(20, " 함수가 실행되었습니다.");

    info1.result();
    info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19.함수가 실행되었습니다.<br>
                            20.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample17 -->
            <div id="sample18" class="sample">
                <h3>18. 함수 유형: 프로토타입 함수</h3>
                <p>
                    프로토타입 함수는 모든 JavaScript 객체가 상속하는 기본 메커니즘입니다. 프로토타입 함수를 사용하면 모든 객체에 공유되는 메서드를 정의할 수 있습니다.
                    JavaScript의 프로토타입 함수는 모든 JavaScript 객체가 상속하는 기본 메커니즘입니다. 프로토타입 함수를 사용하면 모든 객체에 공유되는 메서드를 정의할 수 있습니다.
                    프로토타입 함수를 사용하면 일반적으로 객체 생성자 함수와 함께 사용됩니다. 객체 생성자 함수로 만든 모든 객체는 해당 생성자 함수의 프로토타입을 상속하게 되며, 이는 프로토타입
                    함수가 해당 객체의 메서드로 사용될 수 있음을 의미합니다.
                </p>
                <pre><code>{
    function Func(num, str) {
        this.num = num;
        this.str = str;
    }
    // 메서드 추가
    Func.prototype.result = function () {
        console.log(`${this.num}.${this.str}`);
    }

    // 인스턴스 생성
    const info1 = new Func(21, " 함수가 실행되었습니다.");
    const info2 = new Func(22, " 함수가 실행되었습니다.");

    // 호출
    info1.result();
    info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            21.함수가 실행되었습니다.<br>
                            22.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample18 -->
            <div id="sample19" class="sample">
                <h3>19. 함수 유형: 객체 리터럴 함수</h3>
                <p>
                    JavaScript의 프로토타입 함수(Prototype Functions)는 객체의 프로토타입(Prototype)에 정의된 함수입니다. 모든 JavaScript 객체는 프로토타입을
                    가지며, 프로토타입은 해당 객체를 생성한 생성자 함수(Constructor Function)의 prototype 속성을 가리킵니다.
                    프로토타입 함수는 해당 객체의 모든 인스턴스가 공유하는 함수입니다. 따라서 객체의 생성자 함수의 프로토타입에 메서드를 추가하면 해당 생성자로 생성된 모든 객체에서 그 메서드를
                    사용할 수 있습니다.
                </p>
                <pre><code>{
    function Func(num, str) {
        this.num = num;
        this.str = str;
    }
    // 메서드 추가
    Func.prototype = {
        result1: function () {
            console.log(`${this.num}.${this.str}`);
        },
        result2: function () {
            console.log(`${this.num}.${this.str}`);
        },
    }
    const info1 = new Func(23, " 함수가 실행되었습니다.");
    const info2 = new Func(24, " 함수가 실행되었습니다.");

    // 호출
    info1.result1();
    info2.result2();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            23.함수가 실행되었습니다.<br>
                            24.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample19 -->
            <div id="sample20" class="sample">
                <h3>20. 함수 : 즉시 실행 함수</h3>
                <p>
                    자바스크립트에서 사용되는 함수 표현식의 한 형태입니다. 이것은 함수를 선언하고 즉시 실행하는 패턴을 따릅니다.
                    함수는 선언될 때마다 자동으로 실행되지 않습니다. 대신에, 함수를 호출해야만 실행됩니다.
                </p>
                <pre><code>{
    (function () {
        console.log("15. 실행되었습니다.")
    })();

    (() => {
        console.log("16. 실행되었습니다.")
    })();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15.함수가 실행되었습니다.<br>
                            16.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample20 -->
            <div id="sample21" class="sample">
                <h3>21. 함수 : 파라미터 함수</h3>
                <p>
                    함수를 정의할 때 함수에 전달되는 값을 받을 수 있는 매개변수(parameter)를 가지는 함수입니다. 함수가 호출될 때, 이러한 매개변수는 함수에 값을 전달하기 위해 사용됩니다.
                </p>
                <pre><code>{
    function func(str = "17. 실행되었습니다.") {
        console.log(str);
    }
    func()

    const func1 = (str = "18. 실행되었습니다.") => {
        console.log(str);
    }
    func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            17.함수가 실행되었습니다.<br>
                            18.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample21 -->
            <div id="sample22" class="sample">
                <h3>22. 함수 : 재귀 함수</h3>
                <p>
                    재귀 함수(recursive function)는 함수 내에서 자기 자신을 호출하는 함수입니다. 이러한 호출은 종종 함수의 작업을 반복하거나 문제를 해결하는 데 사용됩니다.<br>
                    //동시에 10개 출력<br>
                    재귀 함수를 작성할 때는 두 가지 주요 요소를 고려해야 합니다<br>
                    종료 조건(Base case): 재귀 호출을 멈추게 하는 조건입니다. 종료 조건을 만족하면 함수가 더 이상 자기 자신을 호출하지 않고 종료됩니다.<br>
                    재귀 단계(Recursive case): 재귀 함수가 자기 자신을 호출하여 작은 부분 문제를 해결하는 단계입니다. 이러한 호출은 종료 조건에 도달할 때까지 계속됩니다.
                </p>
                <pre><code>{    
    // 01 반복문을 사용하는 경우
    function func(num) {
        for (let i = 0; i &LT; num; i++) {
            console.log("19. 실행되었습니다.")
        }
    }
    func(10);

    // 02 재귀함수 사용하는 경우
    function func1(num) {
        if (num &LT; 1) return;

        console.log("20. 실행되었습니다.")
        func1(num - 1);  //재귀 호출
    }
    func1(10);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19.함수가 실행되었습니다.<br>
                            20.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample22 -->
            <div id="sample23" class="sample">
                <h3>23. 함수 : 콜백 함수</h3>
                <p>
                    다른 함수에 인자로 전달되어 실행되는 함수입니다. 이러한 함수는 비동기적인 작업을 처리하거나 함수의 동작을 다이나믹하게 변경하고 확장하기 위해 사용됩니다.<br>
                    콜백 함수는 주로 이벤트 핸들러, 타이머 함수(setTimeout, setInterval), 비동기적인 작업(fetch API, AJAX 호출 등) 등과 함께 사용됩니다.<br>
                    //순서대로 10개 출력
                </p>
                <pre><code>{
    // 01 이벤트
    function func() {
        console.log("21. 실행되었습니다.")
    }
    // btn.addEventListener("click", func);

    // 02 함수를 다른 함수의 인자로 전달
    function func1() {
        console.log("22. 실행되었습니다.")
    }
    function func2(callback) {
        callback();
    }
    func2(func1);

    // 03 반복문을 사용하는 경우
    function func3(num) {
        console.log(num + ". 실행되었습니다.")
    }
    function fun4(callback) {
        for (let i = 23; i &LT; 28; i++)
            callback(i);
    }
    fun4(func3);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            22.함수가 실행되었습니다.<br>
                            23.함수가 실행되었습니다.<br>
                            24.함수가 실행되었습니다.<br>
                            25.함수가 실행되었습니다.<br>
                            26.함수가 실행되었습니다.<br>
                            27.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->
            <div id="sample24" class="sample">
                <h3>24. 함수 : 비동기 방식 : 콜백 함수</h3>
                <p>
                    비동기적 프로그래밍에서 콜백 함수(callback function)는 주로 비동기 작업이 완료되었을 때 실행되는 함수입니다. 비동기 작업은 코드의 흐름을 차단하지 않고 다른 작업을 계속할 수 있도록 해줍니다.비동기 작업을 처리할 때는 작업이 완료되면 어떤 작업을 수행할 것인지를 지정해야 합니다.
                    이때 콜백 함수를 사용합니다. 콜백 함수는 비동기 작업이 완료되면 호출되는 함수로, 작업의 결과를 처리하거나 다음 단계의 작업을 수행하는 데 사용됩니다.
                </p>
                <pre><code>{
    // 동기: 
    // 작업이 순서대로 위에서 아래로 순차적으로 진행. 한 작업이 끝나면 다음 작업이 시작

    // 비동기: 
    // 작업이 순서와 관계없이 여러 작업을 처리할 수 있음
    // 콜백함수, 프로미스, async/aswit 등을 사용하여 작업이 완료될 때 까지 대기하지 않고 다른 작업을 진행할 수 있음

    // 01 동기적인 함수 호출
    function func1() {
        console.log("29. 실행되었습니다.")
    }
    function func2() {
        console.log("30. 실행되었습니다.")
    }
    func1();
    func2();

    // 02 비동기적인 함수 호출
    function func3() {
        setTimeout(() => {
            console.log("31. 실행되었습니다.");
        }, 1000)
    }
    function func4() {
        console.log("32. 실행되었습니다.")
    }
    func3();
    func4();

    // 03 콜백함수 비동기 호출
    {
        function func5(callback) {
            setTimeout(() => {
                console.log("33. 실행되었습니다.")
                callback();
            }, 1000);
        }
        function func6() {
            setTimeout(() => {
                console.log("34. 실행되었습니다.")
            }, 1000);
        }
        func5(function () {
            func6();
        });
    }
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            29.함수가 실행되었습니다.<br>
                            30.함수가 실행되었습니다.<br>
                            31.함수가 실행되었습니다.<br>
                            32.함수가 실행되었습니다.<br>
                            33.함수가 실행되었습니다.<br>
                            34.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample24 -->
            <div id="sample26" class="sample">
                <h3>26. 함수 : 비동기 방식 : async/awiat</h3>
                <p>
                    async/await은 JavaScript의 비동기 처리를 좀 더 간결하고 이해하기 쉽게 만드는 기능입니다. 
                    기존의 콜백 함수나 프라미스를 사용한 비동기 코드보다 더 직관적이며, 동기식 코드와 유사한 스타일로 비동기 작업을 처리할 수 있도록 해줍니다.<br>
                    async 함수: async 키워드를 사용하여 선언된 함수는 항상 프라미스를 반환합니다. 이 함수 내에서 await 키워드를 사용하여 비동기 작업의 완료를 기다릴 수 있습니다.<br>
                    await 표현식: await 키워드는 async 함수 내에서만 사용할 수 있습니다. await는 프라미스가 완료될 때까지 함수의 실행을 일시 중단하고, 프라미스가 완료될 때까지 기다린 다음, 그 결과를 반환합니다.
                     await를 사용하면 비동기 코드를 동기식으로 작성하는 것처럼 보일 수 있습니다.
                </p>
                <pre><code>{
    // 01 : 함수(동기방식)
    function func7() {
        console.log("35. 실행되었습니다.")
    }
    func7();

    // 02 : 함수(비동기방식)
    async function func8() {
        console.log("36. 실행되었습니다.")
    }
    func8();

    //03 : 비동기방식(fetch)
    async function func9() {
        const result = await fetch("https://seodaewon1.github.io/class2024/json/gineungsaJC2005_02.json")
        const data = await result.json();
        console.log(data);
    }
    func9();

    //04 : 비동기 + 에러
    async function func10() {
        try {
            const result = await fetch("https://seodaewon1.github.io/class2024/json/gineungsaJC2005_02.json")
            const data = await result.json();
            console.log(data);
        } catch (error) {
            console.error(error)
        }
        func10();
    }
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            29.함수가 실행되었습니다.<br>
                            30.함수가 실행되었습니다.<br>
                            31.함수가 실행되었습니다.<br>
                            32.함수가 실행되었습니다.<br>
                            33.함수가 실행되었습니다.<br>
                            34.함수가 실행되었습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample26 -->

        </div>
        <!-- //main__sample -->
    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        // 11. 함수 유형 : 함수와 매개변수를 이용한 형태
        {
            function func(x, y) {
                console.log(x, y)
            }
            func("01.", "실행되었습니다.")
        }
        // 12. 함수 유형 : 함수와 변수를 이용한 형태
        {
            const x = "02.", y = "실행되었습니다."

            function func(x, y) {
                console.log(x, y)
            }
            func(x, y)
        }
        // 13. 함수 유형 : 함수와 배열를 이용한 형태
        {
            const x = ["03.", "04."]
            const y = "실행되었습니다."

            function func(x, y) {
                console.log(x, y)
            }
            func(x[0], y)
            func(x[1], y)
        }
        // 14. 함수 유형 : 함수와 객체를 이용한 형태
        {
            const x = {
                a: "05.",
                b: "실행되었습니다"
            }
            function func(x, y) {
                console.log(x, y)
            }
            func(x.a, x.b)
        }
        // 15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태
        {
            const info = [
                { a: "06.", b: "실행되었습니다." },
                { c: "07.", d: "실행되었습니다." }
            ]
            function func(x, y) {
                console.log(x, y)
            }
            func(info[0].a, info[0].b)
            func(info[1].c, info[1].d)
        }
        // 16. 함수 유형 : 객체 안에 함수를 이용한 형태
        {
            const info = {
                num: "08",
                str: "실행되었습니다.",
                result: () => {
                    console.log(info.num + "." + info.str)
                    console.log(`${info.num + "." + info.str}`)
                }
            }
            info.result()
        }
        // 17. 함수 유형 : 객체 생성자 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
                this.result = () => {
                    console.log(`${this.num}. ${this.str}`)
                }
            }
            // 인스턴스 생성
            const info1 = new Func("09", "실행되었습니다.")
            const info2 = new Func("10", "실행되었습니다.")

            // 호출
            info1.result();
            info2.result();
        }
        // 18. 함수 유형 : 프로토타입 함수
        {
            // 함수 정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            // 메서드 추가
            Func.prototype.result = function () {
                console.log(`${this.num}. ${this.str}`)
            }
            const info1 = new Func("11", "실행되었습니다.")
            const info2 = new Func("12", "실행되었습니다.")

            // 호출
            info1.result();
            info2.result();

        }
        // 19. 함수 유형 : 객체 리터럴 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }
            Func.prototype = {
                result1: function () {
                    console.log(`${this.num}. ${this.str}`)
                },
                result2: function () {
                    console.log(`${this.num}. ${this.str}`)
                }
            }
            const info1 = new Func("13", "실행되었습니다.")
            const info2 = new Func("14", "실행되었습니다.")

            info1.result1();
            info2.result2();

        }
        // 20. 함수 : 즉시 실행 함수
        {
            (function () {
                console.log("15. 실행되었습니다.")
            })();

            (() => {
                console.log("16. 실행되었습니다.")
            })();
        }
        // 21. 함수 : 파라미터 함수
        {
            function func(str = "17. 실행되었습니다.") {
                console.log(str);
            }
            func()

            const func1 = (str = "18. 실행되었습니다.") => {
                console.log(str);
            }
            func1();
        }
        // 22. 함수 : 재귀 함수   -> 동시에 10개 출력
        {
            // 01 반복문을 사용하는 경우
            function func(num) {
                for (let i = 0; i < num; i++) {
                    console.log("19. 실행되었습니다.")
                }
            }
            func(10);

            // 02 재귀함수 사용하는 경우
            function func1(num) {
                if (num < 1) return;

                console.log("20. 실행되었습니다.")
                func1(num - 1);  //재귀 호출
            }
            func1(10);
        }
        // 23. 함수 : 콜백 함수   -> 순서대로 10개 출력
        {
            // 01 이벤트
            function func() {
                console.log("21. 실행되었습니다.")
            }
            // btn.addEventListener("click", func);

            // 02 함수를 다른 함수의 인자로 전달
            function func1() {
                console.log("22. 실행되었습니다.")
            }
            function func2(callback) {
                callback();
            }
            func2(func1);

            // 03 반복문을 사용하는 경우
            function func3(num) {
                console.log(num + ". 실행되었습니다.")
            }
            function fun4(callback) {
                for (let i = 23; i < 28; i++)
                    callback(i);
            }
            fun4(func3);
        }
        // 24. 함수 : 비동기 방식 : 콜백 함수
        {
            // 동기: 
            // 작업이 순서대로 위에서 아래로 순차적으로 진행. 한 작업이 끝나면 다음 작업이 시작

            // 비동기: 
            // 작업이 순서와 관계없이 여러 작업을 처리할 수 있음
            // 콜백함수, 프로미스, async/aswit 등을 사용하여 작업이 완료될 때 까지 대기하지 않고 다른 작업을 진행할 수 있음

            // 01 동기적인 함수 호출
            function func1() {
                console.log("29. 실행되었습니다.")
            }
            function func2() {
                console.log("30. 실행되었습니다.")
            }
            func1();
            func2();

            // 02 비동기적인 함수 호출
            function func3() {
                setTimeout(() => {
                    console.log("31. 실행되었습니다.");
                }, 1000)
            }
            function func4() {
                console.log("32. 실행되었습니다.")
            }
            func3();
            func4();

            // 03 콜백함수 비동기 호출
            {
                function func5(callback) {
                    setTimeout(() => {
                        console.log("33. 실행되었습니다.")
                        callback();
                    }, 1000);
                }
                function func6() {
                    setTimeout(() => {
                        console.log("34. 실행되었습니다.")
                    }, 1000);
                }
                func5(function () {
                    func6();
                });
            }
        }
        // 25. 함수 : 비동기 방식 : 프로미스
        // 26. 함수 : 비동기 방식 : async/awiat
        {
            // 01 : 함수(동기방식)
            function func7() {
                console.log("35. 실행되었습니다.")
            }
            func7();

            // 02 : 함수(비동기방식)
            async function func8() {
                console.log("36. 실행되었습니다.")
            }
            func8();

            //03 : 비동기방식(fetch)
            async function func9() {
                const result = await fetch("https://seodaewon1.github.io/class2024/json/gineungsaJC2005_02.json")
                const data = await result.json();
                console.log(data);
            }
            func9();

            //04 : 비동기 + 에러
            async function func10() {
                try {
                    const result = await fetch("https://seodaewon1.github.io/class2024/json/gineungsaJC2005_02.json")
                    const data = await result.json();
                    console.log(data);
                } catch (error) {
                    console.error(error)
                }
                func10();
            }
        }
        // 27. 함수 : 중첩 함수
        // 28. 함수 : 클로저

    </script>
</body>

</html>